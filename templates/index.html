<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YouTube è§†é¢‘ä¸‹è½½å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      .video-grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      }
      
      .video-item {
        background: white;
        border-radius: 0.5rem;
        padding: 1rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: transform 0.2s;
      }
      
      .video-item:hover {
        transform: translateY(-2px);
      }
      
      .video-item video {
        width: 100%;
        height: auto;
        aspect-ratio: 16/9;
        border-radius: 0.25rem;
      }
      
      .video-item p {
        margin: 0.5rem 0;
        font-size: 0.9rem;
        color: #666;
        line-height: 1.4;
      }
    </style>
  </head>
  <body class="bg-gray-100">
    <div class="container mx-auto px-8 py-8">
      <h1 class="text-4xl font-bold text-center mb-4">YouTube è§†é¢‘ä¸‹è½½å™¨</h1>
      <p class="text-center text-gray-600 mb-8">
        è¾“å…¥ YouTube è§†é¢‘é“¾æ¥ï¼Œè½»æ¾ä¸‹è½½é«˜è´¨é‡è§†é¢‘
      </p>

      <div class="max-w-5xl mx-auto">
        <div class="bg-white rounded-lg shadow-md p-6">
          <input
            type="text"
            id="videoUrl"
            class="w-full px-4 py-2 border rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="è¯·è¾“å…¥ YouTube è§†é¢‘é“¾æ¥"
          />

          <button
            onclick="downloadVideo()"
            class="w-full bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition duration-200"
          >
            ä¸‹è½½è§†é¢‘
          </button>

          <div id="progressBar" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2.5">
              <div
                id="progress"
                class="bg-blue-600 h-2.5 rounded-full"
                style="width: 0%"
              ></div>
            </div>
            <p id="progressText" class="text-sm text-gray-600 mt-2">
              å‡†å¤‡ä¸‹è½½...
            </p>
          </div>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 mt-8">
          <h2 class="text-2xl font-bold mb-4">ä¸´æ—¶è®°äº‹æœ¬</h2>
          <button
            onclick="toggleNoteInput()"
            class="bg-purple-500 text-white py-2 px-4 rounded-lg hover:bg-purple-600 transition duration-200 mb-4"
          >
            + æ–°å¢ç¬”è®°
          </button>
          <div id="noteInputArea" class="hidden">
            <textarea 
              id="noteContent"
              class="w-full px-4 py-2 border rounded-lg mb-4 h-32 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="è¾“å…¥éœ€è¦ä¿å­˜çš„å†…å®¹..."
            ></textarea>
            <div class="flex space-x-2">
              <button
                onclick="saveNote()"
                class="bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition duration-200"
              >
                ä¿å­˜
              </button>
              <button
                onclick="toggleNoteInput()"
                class="bg-gray-500 text-white py-2 px-4 rounded-lg hover:bg-gray-600 transition duration-200"
              >
                å–æ¶ˆ
              </button>
            </div>
          </div>
          
          <div id="notesList" class="mt-4 space-y-3">
            <!-- ç¬”è®°ä¼šåŠ¨æ€åŠ è½½åˆ°è¿™é‡Œ -->
          </div>
        </div>

        <div class="mt-8">
          <h2 class="text-2xl font-bold mb-4">å·²ä¸‹è½½çš„è§†é¢‘</h2>
          <div class="video-grid">
            {% for video in videos %}
            <div class="video-item" id="video-{{ loop.index }}">
              <video width="400" height="300" controls>
                <source src="{{ video.path }}" type="video/mp4" />
                Your browser does not support the video tag.
              </video>
              <p class="font-medium break-words line-clamp-2">{{ video.title }}</p>
              <div class="text-center space-y-1">
                <p class="text-sm">{{ video.size }}</p>
                <p class="text-xs text-gray-500">{{ video.date }}</p>
              </div>
              <button
                onclick="deleteVideo(`{{ video.path }}`, `{{ loop.index }}`);"
                class="bg-red-500 text-white py-1 px-3 rounded-lg hover:bg-red-600 transition duration-200"
              >
                åˆ é™¤
              </button>
              <button
                onclick="convertVideo('{{ video.path }}', `{{ loop.index }}`);"
                class="bg-green-500 text-white py-1 px-3 rounded-lg hover:bg-green-600 transition duration-200 mt-2"
              >
                è½¬æ¢æ ¼å¼
              </button>
              <div id="convert-progress-{{ loop.index }}" class="hidden mt-2">
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                  <div
                    class="bg-green-600 h-2.5 rounded-full convert-progress"
                    style="width: 0%"
                  ></div>
                </div>
                <p class="text-sm text-gray-600 mt-2 convert-status">å‡†å¤‡è½¬æ¢...</p>
              </div>
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>

    <!-- ä¿®æ”¹toastä½ç½®ä¸ºé¡µé¢æ­£ä¸­é—´ -->
    <div id="toast" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 px-6 py-3 rounded-lg shadow-md text-white text-lg opacity-0 transition-opacity duration-300 z-50"></div>

    <script>
      let isEditing = false; // æ–°å¢ç¼–è¾‘çŠ¶æ€æ ‡å¿—

      async function downloadVideo() {
        const videoUrl = document.getElementById("videoUrl").value;
        if (!videoUrl) {
          alert("è¯·è¾“å…¥è§†é¢‘é“¾æ¥ï¼");
          return;
        }

        document.getElementById("progressBar").classList.remove("hidden");
        const progressBar = document.getElementById("progress");
        const progressText = document.getElementById("progressText");

        try {
          // å¼€å§‹ä¸‹è½½
          const formData = new FormData();
          formData.append("url", videoUrl);

          const response = await fetch("/download", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          const videoId = data.video_id;

          // è½®è¯¢è¿›åº¦
          const progressInterval = setInterval(async () => {
            try {
              const progressResponse = await fetch(`/progress/${videoId}`);
              const progressData = await progressResponse.json();

              progressBar.style.width = `${progressData.progress}%`;
              progressText.textContent = `ä¸‹è½½è¿›åº¦: ${progressData.progress.toFixed(
                1
              )}%`;

              if (progressData.status === "error") {
                clearInterval(progressInterval);
                progressText.textContent = `ä¸‹è½½å¤±è´¥: ${
                  progressData.error || "æœªçŸ¥é”™è¯¯"
                }`;
                return;
              }

              if (progressData.status === "finished") {
                clearInterval(progressInterval);
                progressText.textContent = "ä¸‹è½½å®Œæˆï¼é¡µé¢å°†åœ¨3ç§’ååˆ·æ–°...";
                setTimeout(() => location.reload(), 3000);
              }
            } catch (error) {
              console.error("Progress check error:", error);
              progressText.textContent = "æ£€æŸ¥è¿›åº¦æ—¶å‡ºé”™";
            }
          }, 1000);
        } catch (error) {
          console.error("Download error:", error);
          progressText.textContent = `ä¸‹è½½å¤±è´¥: ${error.message}`;
        }
      }

      async function deleteVideo(videoPath, index) {
        try {
          const formData = new FormData();
          formData.append("video_path", videoPath);

          const response = await fetch("/delete", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          // åˆ é™¤æˆåŠŸåä»é¡µé¢ç§»é™¤è§†é¢‘
          document.getElementById(`video-${index}`).remove();
        } catch (error) {
          console.error("Delete error:", error);
        }
      }

      async function convertVideo(videoPath, index) {
        const progressDiv = document.getElementById(`convert-progress-${index}`);
        const progressBar = progressDiv.querySelector('.convert-progress');
        const statusText = progressDiv.querySelector('.convert-status');
        progressDiv.classList.remove('hidden');

        try {
          const formData = new FormData();
          formData.append("video_path", videoPath);

          const response = await fetch("/convert", {
            method: "POST",
            body: formData,
          });

          const data = await response.json();
          const taskId = data.task_id;

          const progressInterval = setInterval(async () => {
            const progressResponse = await fetch(`/convert-progress/${taskId}`);
            const progressData = await progressResponse.json();

            progressBar.style.width = `${progressData.progress}%`;
            statusText.textContent = `è½¬æ¢è¿›åº¦: ${progressData.progress.toFixed(1)}%`;

            if (progressData.status === 'error') {
              clearInterval(progressInterval);
              statusText.textContent = `è½¬æ¢å¤±è´¥: ${progressData.error || 'æœªçŸ¥é”™è¯¯'}`;
            }

            if (progressData.status === 'completed') {
              clearInterval(progressInterval);
              statusText.textContent = "è½¬æ¢å®Œæˆï¼é¡µé¢å°†åœ¨3ç§’ååˆ·æ–°...";
              setTimeout(() => location.reload(), 3000);
            }
          }, 1000);
        } catch (error) {
          console.error("è½¬æ¢é”™è¯¯:", error);
          statusText.textContent = `è½¬æ¢å¤±è´¥: ${error.message}`;
        }
      }

      async function saveNote() {
        const content = document.getElementById('noteContent').value;
        if (!content) {
          alert('è¯·è¾“å…¥è¦ä¿å­˜çš„å†…å®¹ï¼');
          return;
        }

        const formData = new FormData();
        formData.append('content', content);

        try {
          const response = await fetch('/save-note', {
            method: 'POST',
            body: formData
          });
          
          if (response.ok) {
            document.getElementById('noteContent').value = '';
            toggleNoteInput();
            loadNotes();
          }
        } catch (error) {
          console.error('ä¿å­˜å¤±è´¥:', error);
        }
      }

      // è‡ªåŠ¨åŠ è½½å’Œåˆ·æ–°ç¬”è®°
      async function loadNotes() {
        const notesList = document.getElementById('notesList');
        try {
          const response = await fetch('/get-notes');
          window.notesData = await response.json(); // æ”¹ä¸ºå…¨å±€å­˜å‚¨
          
          notesList.innerHTML = Object.entries(window.notesData)
            .sort((a, b) => b[0] - a[0]) // æŒ‰æ—¶é—´å€’åº
            .map(([id, note]) => `
              <div class="bg-gray-50 p-3 rounded-lg" data-note-id="${id}">
                <p class="text-gray-600 editable-content">${note.content}</p>
                <div class="flex justify-between items-center mt-2">
                  <span class="text-sm text-gray-400">${note.timestamp}</span>
                  <div class="space-x-2">
                    <button onclick="copyNote('${id}')" class="text-blue-500 hover:text-blue-600 text-sm" title="å¤åˆ¶">
                      å¤åˆ¶
                    </button>
                    <button onclick="startInlineEdit('${id}')" class="text-green-500 hover:text-green-600 text-sm" title="ä¿®æ”¹">
                      ä¿®æ”¹
                    </button>
                    <button onclick="deleteNote('${id}')" class="text-red-500 hover:text-red-600 text-sm" title="åˆ é™¤">
                      åˆ é™¤
                    </button>
                  </div>
                </div>
              </div>
            `).join('');
        } catch (error) {
          console.error('åŠ è½½ç¬”è®°å¤±è´¥:', error);
        }
      }

      // æ·»åŠ åˆ é™¤åŠŸèƒ½ï¼ˆéœ€è¦åç«¯æ”¯æŒï¼‰
      async function deleteNote(noteId) {
        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ç¬”è®°å—ï¼Ÿ')) {
          try {
            const response = await fetch(`/delete-note/${noteId}`, {
              method: 'DELETE'
            });
            if (response.ok) {
              loadNotes();
            }
          } catch (error) {
            console.error('åˆ é™¤å¤±è´¥:', error);
          }
        }
      }

      // ä¿®æ”¹åçš„å¤åˆ¶åŠŸèƒ½
      function copyNote(noteId) {
        const content = window.notesData[noteId]?.content;
        if (content) {
          navigator.clipboard.writeText(content)
            .then(() => showToast('ğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success'))
            .catch(() => {
              showToast('âš ï¸ å¤åˆ¶å¤±è´¥ï¼Œå·²è‡ªåŠ¨é€‰ä¸­æ–‡æœ¬', 'error');
              // è‡ªåŠ¨é€‰ä¸­æ–‡æœ¬ä½œä¸ºå›é€€æ–¹æ¡ˆ
              const noteDiv = document.querySelector(`[data-note-id="${noteId}"]`);
              const range = document.createRange();
              range.selectNodeContents(noteDiv.querySelector('.editable-content'));
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            });
        }
      }

      // ä¿®æ”¹åçš„æç¤ºå‡½æ•°
      function showToast(message, type = 'success') {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.className = `fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 px-6 py-3 rounded-lg shadow-md text-white text-lg ${
          type === 'success' ? 'bg-green-500' : 'bg-red-500'
        } opacity-0 transition-opacity duration-300 z-50`;

        // æ˜¾ç¤ºå¹¶è‡ªåŠ¨éšè—
        toast.classList.remove('opacity-0');
        toast.classList.add('opacity-100');
        
        setTimeout(() => {
          toast.classList.remove('opacity-100');
          toast.classList.add('opacity-0');
        }, 1500);
      }

      // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è·å–ç¬”è®°
      document.addEventListener('DOMContentLoaded', loadNotes);
      // ä¿®æ”¹è‡ªåŠ¨åˆ·æ–°é€»è¾‘
      setInterval(() => {
        if (!isEditing) { // åªæœ‰ä¸åœ¨ç¼–è¾‘çŠ¶æ€æ—¶æ‰åˆ·æ–°
          loadNotes();
        }
      }, 30000);

      // åˆ‡æ¢è¾“å…¥æ¡†æ˜¾ç¤º
      function toggleNoteInput() {
        const inputArea = document.getElementById('noteInputArea');
        inputArea.classList.toggle('hidden');
        document.getElementById('noteContent').value = '';
      }

      // è¡Œå†…ç¼–è¾‘åŠŸèƒ½
      async function startInlineEdit(noteId) {
        isEditing = true; // è¿›å…¥ç¼–è¾‘çŠ¶æ€
        const noteDiv = document.querySelector(`[data-note-id="${noteId}"]`);
        const contentPara = noteDiv.querySelector('.editable-content');
        const originalContent = contentPara.textContent;

        // åˆ›å»ºç¼–è¾‘å…ƒç´ 
        const editArea = document.createElement('div');
        editArea.innerHTML = `
          <div class="w-full max-w-4xl">
            <textarea 
              class="w-full px-4 py-3 border-2 rounded-lg mb-2 text-lg focus:border-blue-500 focus:ring-4 focus:ring-blue-200 transition-all"
              rows="6"
              style="min-height: 150px; line-height: 1.6;"
              id="editContent-${noteId}"
            >${originalContent}</textarea>
            <div class="flex space-x-3 justify-end">
              <button 
                onclick="saveInlineEdit('${noteId}')"
                class="text-sm bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 transition duration-200"
              >
                ä¿å­˜
              </button>
              <button 
                onclick="cancelInlineEdit('${noteId}', '${originalContent}')"
                class="text-sm bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition duration-200"
              >
                å–æ¶ˆ
              </button>
            </div>
          </div>
        `;

        // æ›¿æ¢åŸæœ‰å†…å®¹
        contentPara.replaceWith(editArea);
      }

      // ä¿å­˜ç¼–è¾‘
      async function saveInlineEdit(noteId) {
        try {
          const newContent = document.getElementById(`editContent-${noteId}`).value;
          if (!newContent.trim()) {
            alert('å†…å®¹ä¸èƒ½ä¸ºç©º');
            return;
          }

          const formData = new FormData();
          formData.append('content', newContent);

          const response = await fetch(`/edit-note/${noteId}`, {
            method: 'PUT',
            body: formData
          });

          if (response.ok) {
            isEditing = false; // é€€å‡ºç¼–è¾‘çŠ¶æ€
            await loadNotes(); // ç­‰å¾…åˆ·æ–°å®Œæˆ
          } else {
            alert('ä¿å­˜å¤±è´¥ï¼Œè¯·ç»§ç»­ç¼–è¾‘');
          }
        } catch (error) {
          console.error('ä¿å­˜å¤±è´¥:', error);
          alert('ä¿å­˜æ—¶å‘ç”Ÿé”™è¯¯');
        }
      }

      // å–æ¶ˆç¼–è¾‘
      function cancelInlineEdit(noteId, originalContent) {
        isEditing = false; // é€€å‡ºç¼–è¾‘çŠ¶æ€
        const noteDiv = document.querySelector(`[data-note-id="${noteId}"]`);
        const editArea = noteDiv.querySelector('textarea').parentElement;
        
        // æ¢å¤åŸå§‹å†…å®¹
        const contentPara = document.createElement('p');
        contentPara.className = 'text-gray-600 editable-content';
        contentPara.textContent = originalContent;
        
        editArea.replaceWith(contentPara);
      }
    </script>
  </body>
</html>
